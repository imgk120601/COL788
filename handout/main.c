/**
  ******************************************************************************
  * @file    main.c
  * @author  System Research & Applications Team - Catania Lab.
  * @version V2.1.0
  * @date    15-May-2020
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2020 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/**
 * @mainpage FP-SNS-ALLMEMS2 Bluetooth Low Energy and Sensors Software
 *
 * @image html st_logo.png
 *
 * <b>Introduction</b>
 *
 * This firmware package includes Components Device Drivers, Board Support Package
 * and example application for the following STMicroelectronics elements:
 * - STEVAL-MKSBOX1V1 (SensorTile.box) evaluation board that contains the following components:
 *     - MEMS sensor devices: HTS221, LPS22HH, STTS751, LIS2MDL, LIS2DW12, LIS3DHH, LSM6DSOX
 *     - analog microphone: MP23ABS1
 * - MotionAR software provides real-time activity recognition data using MEMS accelerometer sensor
 * - MotionCP software provides carry Position recognition data using MEMS accelerometer sensor
 * - MotionFX (iNEMOEngine PRO) suite uses advanced algorithms to integrate outputs
 *   from multiple MEMS sensors in a smartway, independent of environmental conditions,
 *   to reach optimal performance. Real-time motion-sensor data fusion is set to significantly
 *   improve the user experience, increasing accuracy, resolution, stability and response time.
 * - MotionGR (iNEMOEngine PRO) software provides carry Gesture recognition data using MEMS accelerometer sensor
 * - BlueVoiceADPCM software enables real-time half-duplex voice-over-Bluetooth low energy communication profile.
 *   It includes one characteristic for audio transmission and one for synchronization and it is responsible for audio encoding and periodical data
 *   transmission on Server side and for decoding of received voice data on Client side
 * - USB device library provides support of multi packet transfer to allow sending big amount of data without split 
 *   them into max packet size transfers.
 * - FatFs generic FAT file system module provides access the storage devices such as memory card and hard disk.
 * - FreeRTOS Real Time Kernel/Scheduler that allows applications to be organized as a collection of independent threads of execution
 *   (under MIT open source license)
 *
 * <b>Example Application</b>
 *
 * The Example application initializes all the Components and Library creating 3 Custom Bluetooth services:
 * - The first service exposes all the HW and SW characteristics:
 *  - HW characteristics:
 *     - related to MEMS sensor devices: Temperature, Humidity, Pressure, Magnetometer, Gyroscope and Accelleromenter 
 *       and Microphones Signal Noise dB level.
 *     - battery alarm output
 *  - SW characteristics:
 *     - the quaternions generated by the MotionFX library in short precision
 *     - the activity recognized using the MotionAR algorithm
 *     - the carry position recognized using the MotionCP algorithm,
 *     - the Gesture recognized using the MotionGR algorithm
 *     - FatFs generic FAT file system for SD card data logging for environmental, mens and audio data.
 *       This functionality on SensorTile.box board is enabled as default through the code in the line 
 * 	 <br>  #define ALLMEMS2_ENABLE_SD_CARD_LOGGING
 * 	 <br>on file:
 * 	 <br>  Projects\STM32L4R9ZI-SensorTile.box\Applications\ALLMEMS2\Inc\ALLMEMS2_config.h
 * - The second Service exposes the console services where we have stdin/stdout and stderr capabilities
 * - The last Service is used for configuration purpose
 * 
 * The example application allows the user to control the initialization phase via UART.
 * Launch a terminal application and set the UART port to 9600 bps, 8 bit, No Parity, 1 stop bit.
 * <br>For having the same UART functionality on SensorTile board, is necessary to recompile the code uncomment the line
 * <br>  //#define ALLMEMS2_ENABLE_PRINTF
 * <br>on file:
 * <br>  Projects\STM32L4R9ZI-SensorTile.box\Applications\ALLMEMS2\Inc\ALLMEMS2_config.h
 * <br>This enables the UART that starts with a delay of 10 Seconds for allowing the time to open the UART for looking
 * the initialization phase.
 *
 * This example must be used with the related ST BLE Sensor Android/iOS application available on Play/itune store (Version 4.5.0 or higher),
 * in order to read the sent information by Bluetooth Low Energy protocol
 *
 *                              -------------------
 *                              | VERY IMPORTANT  |
 *                              -------------------
 * 1) This example support the Firmware-Over-The-Air (FOTA) update using the ST BLE Sensor Android/iOS
 * application (Version 3.0.0 and above)
 *
 * 2) This example must run starting at address 0x08004000 in memory and works ONLY if the BootLoader 
 * is saved at the beginning of the FLASH (address 0x08000000)
 *
 * 3) If the user presses the blue user button on Nucleo board, 3 times on less that 2 seconds,
 * he forces a new Calibration for MotionFX Library
 * The calibration value could be stored on FLASH memory or in RAM for avoiding to do the calibration at each board reset
 *
 * 4) For each IDE (IAR/ÂµVision/System Workbench) there are some scripts *.bat and *.sh that makes the following operations:
 * - Full Flash Erase
 * - Load the BootLoader on the rigth flash region
 * - Load the Program (after the compilation) on the rigth flash region (This could be used for a FOTA)
 * - Dump back one single binary that contain BootLoader+Program that could be
 *   flashed at the flash beginning (address 0x08000000) (This COULD BE NOT used for FOTA)
 * - Reset the board.
 * .
 *
 *                               --------------------
 *                               | KNOWN LIMITATION |
 *                               --------------------
 * - Even if FP-SNS-ALLMEMS1 send 100 quaternions/second with Bluetooth, the mobile devices could render only 60 frames/second
 */

/* Includes ------------------------------------------------------------------*/
#include <stdio.h>
#include <math.h>
#include <limits.h>

#include "TargetFeatures.h"
#include "cmsis_os.h"
#include "main.h"
#include "OTA.h"
#include "MetaDataManager.h"
#include "bluenrg_utils.h"

#include "DataLog_Manager.h"
#include "datalog_application.h"

#include "PowerControl.h"
#ifdef ENABLE_SHUT_DOWN_MODE 
  #include "HWAdvanceFeatures.h"
#endif /* ENABLE_SHUT_DOWN_MODE */
   
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
#include "DataLog_Manager.h"
#include "datalog_application.h"
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */ 

/* Private typedef -----------------------------------------------------------*/

/* Private define ------------------------------------------------------------*/

#define BLUEMSYS_N_BUTTON_PRESS 3
#define BLUEMSYS_CHECK_CALIBRATION ((uint32_t)0x12345678)
   
#define LED_TIME_OFF 2000UL /* shall not be same than ON time */
#define LED_TIME_ON   100UL

#ifdef ENABLE_SHUT_DOWN_MODE 
  //#define SHUT_DOWN_TIME_OUT 20000UL
  void MCU_PowerSave(void);
  void MCU_PowerSaveExit(void);
#endif /* ENABLE_SHUT_DOWN_MODE */

/* Imported Variables -------------------------------------------------------------*/
extern uint8_t set_connectable;
extern int connected;
static int hciProcessEnable = 1;

/* Code for MotionAR integration - Start Section */
extern MAR_output_t ActivityCode;
/* Code for MotionAR integration - End Section */

/* Code for MotionCP integration - Start Section */
extern MCP_output_t CarryPositionCode;
/* Code for MotionCP integration - End Section */

/* Code for MotionGR integration - Start Section */
extern MGR_output_t GestureRecognitionCode;
/* Code for MotionGR integration - End Section */

extern volatile float RMS_Ch[];
extern float DBNOISE_Value_Old_Ch[];
extern uint16_t PCM_Buffer[];

extern volatile float RMS_Ch[];
extern float DBNOISE_Value_Old_Ch[];
extern uint16_t PCM_Buffer[];


#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
extern uint8_t IsSdMemsRecording;
extern uint8_t IsSdAudioRecording;

extern volatile uint8_t writeAudio_flag;

extern uint8_t SD_CardLogging_StepHours;
extern uint8_t SD_CardLogging_StepMinutes;
extern uint8_t SD_CardLogging_StepSeconds;

/* SD card logging status (stop=0, start=1) */
extern uint8_t  SD_Card_Status;
/* Feature mask that identify the data mens selected for recording*/
extern uint32_t SD_Card_FeaturesMask;
/* Time range for data recording in second */
extern uint32_t SD_Card_StepTime;

extern uint16_t sdcard_file_counter;

#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */


/* Exported Variables --------------------------------------------------------*/
osSemaphoreId semRun;

float sensitivity;
/* Acc sensitivity multiply by FROM_MG_TO_G constant */
float sensitivity_Mul;

MFX_MagCal_output_t magOffset;
MOTION_SENSOR_Axes_t MAG_Offset; 

uint32_t ConnectionBleStatus  =0;

uint32_t ForceReCalibration    =0;
uint32_t FirstConnectionConfig =0;

uint8_t BufferToWrite[256];
int32_t BytesToWrite;

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
RTC_DateTypeDef CurrentDate;
RTC_TimeTypeDef CurrentTime;
volatile uint32_t SD_CardLogging  =0;

/* Enable ShutDown Mode as default with SD card logging features*/
uint8_t ShutDownAllowed= 1;

#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
/* RTC handler declaration */
RTC_HandleTypeDef RtcHandle;
uint8_t bdaddr[6];

uint32_t MagCalibrationData[30];
uint8_t  NodeName[8];

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  uint32_t DataLogStatus[5];
  char MemsDataFileName[41];
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */

/* Table with All the known Meta Data */
MDM_knownGMD_t known_MetaData[]={
  {GMD_MAG_CALIBRATION,    (sizeof(MagCalibrationData))},
  {GMD_NODE_NAME,      (sizeof(NodeName))},
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  {GMD_DATA_LOG_STATUS,    (sizeof(DataLogStatus))},
  {GMD_MEMS_DATA_FILENAME, (sizeof(MemsDataFileName))},
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
  {GMD_END    ,0}/* THIS MUST BE THE LAST ONE */
};


uint16_t PedometerStepCount= 0;
static CRC_HandleTypeDef hcrc;

volatile uint8_t SD_LogAudio_Enabled = 0;

/* Private variables ---------------------------------------------------------*/
static volatile int           ButtonPressed    = 0 ;
static volatile int           MEMSInterrupt    = 0 ;
static volatile uint32_t      HCI_ProcessEvent = 0 ;
static volatile uint32_t      SendEnv          = 0 ;
static volatile uint32_t      SendAudioLevel   = 0 ;
static volatile uint32_t      SendAccGyroMag   = 0 ;
static volatile uint32_t      ledTimer         = 0 ;
static volatile hostLinkType_t hostConnection  = NOT_CONNECTED ;
static volatile uint32_t TimeStamp = 0;

volatile int PowerButtonPressed                = 0;

static volatile uint32_t SendBatteryInfo =0;

/* Code for MotionFX integration - Start Section */
static volatile uint32_t Quaternion      =0;
/* Code for MotionFX integration - End Section */

/* Code for MotionAR integration - Start Section */
static volatile uint32_t UpdateMotionAR  =0;
/* Code for MotionAR integration - End Section */

/* Code for MotionCP integration - Start Section */
static volatile uint32_t UpdateMotionCP  =0;
/* Code for MotionCP integration - End Section */

/* Code for MotionGR integration - Start Section */
static volatile uint32_t UpdateMotionGR  =0;
/* Code for MotionGR integration - End Section */

unsigned char isCal = 0;
static uint32_t mag_time_stamp = 0;

void SystemClock_Config(void);

#ifdef ENABLE_SHUT_DOWN_MODE 
  /* Accelerometer event wakeup mode selection */
  const uint8_t WakeupSource = ACC_DOUBLE_TAP;

  /* flag initialized at 0, set when exit from shutdown detected */
  static volatile uint32_t out_of_shutdown;
#endif /* ENABLE_SHUT_DOWN_MODE */
  
/* Private function prototypes -----------------------------------------------*/

static void Init_BlueNRG_Custom_Services(void);
static void Init_BlueNRG_Stack(void);

static unsigned char ResetCalibrationInMemory(void);

static unsigned char ReCallNodeNameFromMemory(void);

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  static unsigned char ReCallDataLogStatusFromMemory(void);
  static unsigned char ReCallMemsDataFileNameFromMemory(void);
  static void SdCardMemsRecordingRun(void);
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */

static void MX_CRC_Init(void);

static void SendEnvironmentalData(void);
static void MEMSCallback(void);
static void MagCalibTest(void);
static void ReCalibration(void);
static void ButtonCallback(void);
static void SendMotionData(void);
static void SendAudioLevelData(void);

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  //static void RTC_Config(void);
  static void AddSecOrMin(uint8_t CurrentValue, uint8_t AddValue, uint8_t *Overflow, uint8_t *NewValue);
  static void AddHours(uint8_t CurrentValue, uint8_t AddValue, uint8_t *NewValue);
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */


static void LedBlinkCb(void const *arg);
#ifdef ENABLE_SHUT_DOWN_MODE 
static void ShutDownTimeOutCb(void const *arg);
#endif /* ENABLE_SHUT_DOWN_MODE */

static int  HardwareInit(void);

static void InitLibraries(void);
static void ProcessThread(void const *argument);
static void HostThread   (void const *argument);

static void SendBatteryInfoData(void);

void AudioProcess_DB_Noise(void);

void APP_UserEvtRx(void *pData);

/* Code for MotionFX integration - Start Section */
static void ComputeQuaternions(void);
/* Code for MotionFX integration - End Section */

/* Code for MotionAR integration - Start Section */
static void ComputeMotionAR(void);
/* Code for MotionAR integration - End Section */

/* Code for MotionCP integration - Start Section */
static void ComputeMotionCP(void);
/* Code for MotionCP integration - End Section */

/* Code for MotionGR integration - Start Section */
static void ComputeMotionGR(void);
/* Code for MotionGR integration - End Section */

extern int hci_flush_ReadQ(void);

extern tBleStatus Config_NotifyBLE(uint32_t Feature,uint8_t Command,uint8_t data);
static void startProcessing (void const *arg);                   

osTimerId timLedId,timEnvId,timBatId,timQuatId,timMotionId,timCompassId,timBattPlugId;
osTimerId timAudioLevId,timAudioLocId,timCarryId,timGestureId,timActivityId;

/* CMSIS-OS  definitions                                                        */
/* threads */
osThreadDef(THREAD_1, ProcessThread, osPriorityNormal     , 0, configMINIMAL_STACK_SIZE*8);
osThreadDef(THREAD_2, HostThread   , osPriorityAboveNormal, 0, configMINIMAL_STACK_SIZE*5);

/* Semaphores */
osSemaphoreDef(SEM_Sm1);
/* Mail Queue */
osMailQId  mail;                                               // Mail queue ID
osMailQDef(mail, 70, msgData_t);
/* Timers */
osTimerDef (TimerLedHandle , LedBlinkCb);
osTimerDef (TimerEnvHandle , startProcessing);
osTimerDef (TimerBatHandle , startProcessing);
osTimerDef (TimerBattPlugHandle , startProcessing);
osTimerDef (TimerQuatHandle, startProcessing);
osTimerDef (TimerMotionHandle, startProcessing);
osTimerDef (TimerCompassHandle, startProcessing);
osTimerDef (TimerAudioLevHandle, startProcessing);
osTimerDef (TimerAudioLocHandle, startProcessing);
osTimerDef (TimerCarryHandle, startProcessing);
osTimerDef (TimerGestureHandle, startProcessing);
osTimerDef (TimerActivityHandle, startProcessing);

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
osTimerId timSdCardLoggingId;
osTimerDef (TimerSdRecordingHandle , startProcessing);
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */

#ifdef ENABLE_SHUT_DOWN_MODE 
osTimerId  timShutDownId;
osTimerDef (TimerShutDownTimeOutHandle, ShutDownTimeOutCb);
#endif /* ENABLE_SHUT_DOWN_MODE */

/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
  HardwareInit();

#if ( configUSE_TRACE_FACILITY == 1 )
  vTraceEnable(TRC_START);
#endif

  /* Create threads                                                           */
  osThreadCreate(osThread(THREAD_1), NULL);
  osThreadCreate(osThread(THREAD_2), NULL);

  /* Create the semaphores                                                    */
  semRun = osSemaphoreCreate(osSemaphore(SEM_Sm1), 1);

  /* create mail queue                                                        */
  mail = osMailCreate(osMailQ(mail), NULL);      

  /* set lowest reachable power mode                                          */

#ifdef ALLMEMS2_ENABLE_PRINTF
  SetMinPowerMode(IDLE_WFI_TICK_SUPRESS);
  //CDC_PeriodElapsedCallback();
#else
  SetMinPowerMode(IDLE_SLEEP_STOP);
#endif /* ALLMEMS2_ENABLE_PRINTF */
  
  /* Start scheduler                                                          */
  osKernelStart();
 
  /* We should never get here as control is now taken by the scheduler        */
  for (;;);
}

static void ProcessThread(void const *argument) 
{
  msgData_t msg;

//  int pref_logtime = HAL_GetTick();
  uint32_t time_start= HAL_GetTick();
  uint32_t tdelay = 5000;//5sec
  SD_CardLoggingMemsStart();

  while (1){
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
    RTC_GetCurrentDateTime();
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
    
   if (semRun != NULL){
        if(osSemaphoreWait(semRun, osWaitForever) == osOK){ 
          if(set_connectable){
          InitLibraries();
          if(NecessityToSaveMetaDataManager) {
            uint32_t Success = EraseMetaDataManager();
            if(Success) {
              SaveMetaDataManager();
            }
          }
          msg.type  = SET_CONNECTABLE ;
          SendMsgToHost(&msg);
          set_connectable =0;
        }
        /* Handle Interrupt from MEMS */
        if(MEMSInterrupt) {
          MEMSCallback();
          MEMSInterrupt=0;
#ifdef ENABLE_SHUT_DOWN_MODE           
          ShutdownTimeOutReset();
#endif /* ENABLE_SHUT_DOWN_MODE */
        }

        /* Handle user button */
        if(ButtonPressed) {
          ButtonCallback();
          ButtonPressed=0;       
        }
        
        /* Power Off the SensorTile.box */
//        if(PowerButtonPressed){
//          BSP_BC_CmdSend(SHIPPING_MODE_ON);
//          PowerButtonPressed =0;
//        }

        /* Handle Re-Calibration */
        if(ForceReCalibration) {
          ForceReCalibration=0;
          ReCalibration();
        }
        /* Environmental Data */
        if(SendEnv) {
          SendEnv=0;
          SendEnvironmentalData();
        }
        /* Mic Data */
        if (SendAudioLevel) {
          SendAudioLevel = 0;
          SendAudioLevelData();
        }
  
        /* Battery Info Data */
        if(SendBatteryInfo) {
          SendBatteryInfo=0;
          SendBatteryInfoData();
        }

      /* Motion Data */
        if(SendAccGyroMag) {
          SendAccGyroMag=0;
          SendMotionData();
        }
      /* Code for MotionFX integration - Start Section */
        if(Quaternion) {
          Quaternion=0;
          ComputeQuaternions();
        }
      /* Code for MotionFX integration - End Section */

      /* Code for MotionAR integration - Start Section */
        if(UpdateMotionAR) {
          UpdateMotionAR=0;
          ComputeMotionAR();
        }
      /* Code for MotionAR integration - End Section */

      /* Code for MotionCP integration - Start Section */
        if(UpdateMotionCP) {
          UpdateMotionCP=0;
          ComputeMotionCP();
      }
      /* Code for MotionCP integration - End Section */

      /* Code for MotionGR integration - Start Section */
        if(UpdateMotionGR) {
          UpdateMotionGR=0;
          ComputeMotionGR();
        }
      /* Code for MotionGR integration - End Section */
        
      #ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
        if(SD_CardLogging) // For mems data
        {
          SD_CardLogging=0;
          SdCardMemsRecordingRun();
        }    

        if(writeAudio_flag) // for Audio data
        {
          writeAudio_flag=0;
          writeAudio_on_sd();
        }
      #endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */      
        }

//        timetaken++;
        if(HAL_GetTick()-time_start >= tdelay){
			SD_CardLoggingMemsStop();

			time_start = HAL_GetTick();

			SD_CardLoggingMemsStart();
		}
//        if(HAL_GetTick() - pref_logtime >= (5*60*1000)){
//        	SD_CardLoggingMemsStop();
//
//        	pref_logtime = HAL_GetTick();
//
//        	SD_CardLoggingMemsStart();
//        }
    }
   
#ifdef ALLMEMS2_ENABLE_PRINTF
   CDC_PeriodElapsedCallback();
#endif /* ALLMEMS2_ENABLE_PRINTF */
  }
}

int SendMsgToHost(msgData_t *msgPtr)
{
  msgData_t *ptr;
  if (mail)
  {
    ptr = osMailAlloc(mail, osWaitForever);       // Allocate memory
    if (ptr)
    {
      BLUENRG_memcpy(ptr,msgPtr, sizeof(msgData_t));
      osMailPut(mail, ptr);
    }
    else
    {
      ALLMEMS2_PRINTF("SendMsgToHost: mem allocation failed %d\r\n",msgPtr->type);
      return 0; 
    }
    
    //FosMailFree (mail, msgPtr);
  }
  return 1; 
}

static void HostThread(void const *argument) 
{
  msgData_t *msgPtr;
  osEvent  evt;

  for (;;) {
    evt = osMailGet(mail, osWaitForever);        // wait for mail
    if (evt.status == osEventMail) {
      msgPtr = evt.value.p;
      switch(msgPtr->type)
      {
        case SET_CONNECTABLE:
          hciProcessEnable = 1 ;
          setConnectable();
          hostConnection = NOT_CONNECTED;

          
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
          //if( (!IsSdMemsRecording) && (!IsSdAudioRecording) )
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
          {
            LedBlinkStart();
          }
          
#ifdef ENABLE_SHUT_DOWN_MODE
  #ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
          if((!IsSdAudioRecording) && (ShutDownAllowed))
  #endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
          {
            ShutdownTimeOutStart();
          }
#endif /* ENABLE_SHUT_DOWN_MODE */
          break;
		  
        case SET_NOT_CONNECTABLE:
          LedBlinkStop();
          hciProcessEnable = 0 ;
          setNotConnectable();
          hostConnection = NOT_CONNECTED;
          break;
          
        case SET_HOST_LINK_TYPE:
          if (msgPtr->HostLinkType != hostConnection)
          {
#ifdef BLE_LINK_ADAPT

            switch (msgPtr->HostLinkType)
            {
              case AUDIO_HOST_LINK:
                setConnectionParameters(8,17,0,400);
                break;
              case MOTION_HOST_LINK: 
                setConnectionParameters(8,17,0,400);
                break;
              case ENV_HOST_LINK:
                setConnectionParameters(400,400,0,400);
                break;
              case DEFAULT_HOST_LINK:
                setConnectionParameters(400,400,0,400);
                break;
              default:
                break;
            }
#endif /* BLE_LINK_ADAPT */
            hostConnection = msgPtr->HostLinkType;
          }
          break;
		           
        case  PROCESS_EVENT :
          if (hciProcessEnable)
          {
            hci_user_evt_proc();
          }
          break;

        case  CONF_NOTIFY :
          Config_NotifyBLE(msgPtr->conf.feature,msgPtr->conf.command,msgPtr->conf.data);
#ifdef ENABLE_SHUT_DOWN_MODE 
          ShutdownTimeOutStop();
#endif /* ENABLE_SHUT_DOWN_MODE */
          break;

        case  ACC :
          AccEvent_Notify(msgPtr->acc, 2);
          break;

        case  ACC_STEP :
          if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER))
            AccEvent_Notify(msgPtr->stepCnt, 2);
          if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS))
            AccEvent_Notify(msgPtr->stepCnt, 3);
          break;

        case  AUDIO_LEV :
          AudioLevel_Update(msgPtr->DBNOISE_Value_Ch);
          break;

        case  ENV :
          Environmental_Update(msgPtr->env.press,msgPtr->env.hum,msgPtr->env.temp2, msgPtr->env.temp1);
          break;

        case MOTION :
          AccGyroMag_Update(&(msgPtr->motion.acc),&(msgPtr->motion.gyr),&(msgPtr->motion.mag));
          break;

        case QUAT :
          Quat_Update(msgPtr->quat);
          break;

        case COMPASS :
          ECompass_Update(msgPtr->angle);
          break;

        case ACTIVITY:
          ActivityRec_Update(msgPtr->activity);
          break;
          
        case CARRY:
          CarryPosRec_Update(msgPtr->carry);
          break;

        case GESTURE:
          GestureRec_Update(msgPtr->gesture);
          break;

        case BATTERY_INFO:
          BatteryInfoUpdate(msgPtr->batteryInfo.voltage,
                            msgPtr->batteryInfo.level,
                            msgPtr->batteryInfo.soc_status,
                            msgPtr->batteryInfo.current); 
          break;
          
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING          
      case SD_CARD_LOGGING:
        break;
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */        
        case TERM_STDOUT:
          UpdateTermStdOut(msgPtr->term.data,msgPtr->term.length);
          break;
          
        case TERM_STDERR:
          UpdateTermStdErr(msgPtr->term.data,msgPtr->term.length);
          break;
          
        default :
          ALLMEMS2_PRINTF("HostThread unexpected message:%d\r\n",msgPtr->type );
      }
      osMailFree(mail, msgPtr);                                              /* free memory allocated for mail */
      if( semRun    ) osSemaphoreRelease(semRun);                            /* check subsequent processing    */
    }
  }
}

static int HardwareInit(void)
{
  HAL_Init();

  /* Configure the System clock */
  SystemClock_Config();

  initPowerController();

  InitTargetPlatform();
  
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  
  #ifdef ENABLE_SHUT_DOWN_MODE 
    if(!out_of_shutdown)
  #endif /* ENABLE_SHUT_DOWN_MODE */
  {
    /* Configure RTC Data */
    /* Set Default Date: Monday October 30th 2020 */
//    RTC_DataConfig(RTC_WEEKDAY_MONDAY, 0x09, RTC_MONTH_OCTOBER, 0x17);
    
    /* Configure RTC Time */
    /* Set Time: 00:00:00 */
//    RTC_TimeConfig(0x00, 0x00, 0x00);
  }
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */

  Set2GAccelerometerFullScale();
  InitHWFeatures();

  //Disable_MEM1_Sensors();

  
  /* For enabling CRC clock for using motion libraries (for checking if STM32 microprocessor is used)*/
  MX_CRC_Init();
  
  /* Check the MetaDataManager */
 InitMetaDataManager((void *)&known_MetaData,MDM_DATA_TYPE_GMD,NULL); 
  
  ALLMEMS2_PRINTF("\n\t(HAL %ld.%ld.%ld_%ld)\r\n"
        "\tCompiled %s %s"

#if defined (__IAR_SYSTEMS_ICC__)
        " (IAR)\r\n"
#elif defined (__CC_ARM)
        " (KEIL)\r\n"
#elif defined (__GNUC__)
        " (STM32CubeIDE)\r\n"
#endif
         "\tSend Every %4dmS %d Short precision Quaternions\r\n"
         "\tSend Every %4dmS Temperature/Humidity/Pressure\r\n"
         "\tSend Every %4dmS Acc/Gyro/Magneto\r\n"
         "\tSend Every %4dmS dB noise\r\n\n",
           HAL_GetHalVersion() >>24,
          (HAL_GetHalVersion() >>16)&0xFF,
          (HAL_GetHalVersion() >> 8)&0xFF,
           HAL_GetHalVersion()      &0xFF,
         __DATE__,__TIME__,
         QUAT_UPDATE_MUL_10MS*10,SEND_N_QUATERNIONS,
         DEFAULT_ENV_PERIOD,
         DEFAULT_uhCCR4_Val/10,
         DEFAULT_AUDIO_LEV_PERIOD);

#ifdef ALLMEMS2_DEBUG_CONNECTION
  ALLMEMS2_PRINTF("Debug Connection     Enabled\r\n");
#endif /* ALLMEMS2_DEBUG_CONNECTION */

#ifdef ALLMEMS2_DEBUG_NOTIFY_TRAMISSION
  ALLMEMS2_PRINTF("Debug Notify Trasmission Enabled\r\n\n");
#endif /* ALLMEMS2_DEBUG_NOTIFY_TRAMISSION */
  
  /* Set Node Name */
  ReCallNodeNameFromMemory();
  
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  ReCallDataLogStatusFromMemory();
  ReCallMemsDataFileNameFromMemory();

#ifdef ENABLE_SHUT_DOWN_MODE 
  if(out_of_shutdown)
  {
    IsSdMemsRecording= (uint8_t)DataLogStatus[1];
    SD_Card_Status= (uint8_t)DataLogStatus[1];
    SD_Card_FeaturesMask= DataLogStatus[2];
    SD_Card_StepTime= DataLogStatus[3];
    sdcard_file_counter= (uint16_t)DataLogStatus[4];
    
    if(__HAL_RTC_ALARM_GET_FLAG(&RtcHandle, RTC_FLAG_ALRAF))
    {
      SD_CardLogging= 1;
    }
    else
    {
      if(SD_Card_Status)
      {
        RTC_AlarmTypeDef sAlarm;
        HAL_RTC_GetAlarm(&RtcHandle, &sAlarm, RTC_ALARM_A, RTC_FORMAT_BCD);
        HAL_RTC_SetAlarm_IT(&RtcHandle,&sAlarm, RTC_FORMAT_BCD);
      }
    }
  }
  else
#endif /* ENABLE_SHUT_DOWN_MODE */ 
  {
    DataLogStatus[0]= (uint32_t)0x12345678;
    DataLogStatus[1]= (uint32_t)0x00000000;
    DataLogStatus[2]= (uint32_t)0x00000000;
    DataLogStatus[3]= SD_Card_StepTime;
    DataLogStatus[4]= sdcard_file_counter;
    MDM_SaveGMD(GMD_DATA_LOG_STATUS,(void *)&DataLogStatus);
    NecessityToSaveMetaDataManager=1;
  }
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
  
  /* Initialize the BlueNRG */
  Init_BlueNRG_Stack();

  /* Initialize the BlueNRG Custom services */
  Init_BlueNRG_Custom_Services();  
 
  /* Check the BootLoader Compliance */
  ALLMEMS2_PRINTF("\r\n");
  if(CheckBootLoaderCompliance()) {
    ALLMEMS2_PRINTF("BootLoader Compliant with FOTA procedure\r\n\n");
  } else {
    ALLMEMS2_PRINTF("ERROR: BootLoader NOT Compliant with FOTA procedure\r\n\n");
  }
  
  PowerButtonPressed  =0;
 
  return 0;
}

static void InitLibraries(void) 
{
  /* Code for MotionFX integration - Start Section */
  /* Initialize MotionFX library */ 
  if(TargetBoardFeatures.MotionFXIsInitalized==0)
  {
    MotionFX_manager_init();
    MotionFX_manager_start_9X();
    /* Enable magnetometer calibration */
    MagCalibTest();
  }
  /* Code for MotionFX integration - End Section */

  /* Code for MotionAR integration - Start Section */ 
  /* Initialize MotionAR Library */ 
  if(TargetBoardFeatures.MotionARIsInitalized==0)
    MotionAR_manager_init();
  /* Code for MotionAR integration - End Section */

/* Code for MotionCP integration - Start Section */
  /* Initialize MotionCP Library */ 
  if(TargetBoardFeatures.MotionCPIsInitalized==0)
    MotionCP_manager_init();
/* Code for MotionCP integration - End Section */

/* Code for MotionGR integration - Start Section */
  /* Initialize MotionGR Library */
  if(TargetBoardFeatures.MotionGRIsInitalized==0)
    MotionGR_manager_init();
/* Code for MotionGR integration - End Section */
}

static void startProcessing  (void const *arg) 
{ 
  if     (arg == timEnvId){
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV))
      SendEnv=1;
  }
  else if     (arg == timBatId){
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_BATTERY_FEATURES_EVENT))
      SendBatteryInfo= 1;
  }
  else if (arg == timQuatId){
    if ((W2ST_CHECK_CONNECTION(W2ST_CONNECT_QUAT)) | (W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC)))
      Quaternion=1;
  }
  else if (arg == timMotionId){
    SendAccGyroMag=1;
  }
  else if (arg == timAudioLevId){
    SendAudioLevel=1;
  }

  else if (arg == timCarryId){
    UpdateMotionCP=1;
  }
  else if (arg == timGestureId){
    UpdateMotionGR=1;
  }

  else if (arg == timActivityId){
    UpdateMotionAR=1;
    TimeStamp += ALGO_PERIOD_AR;
  }
  else if (arg == timCompassId){
    if ((W2ST_CHECK_CONNECTION(W2ST_CONNECT_QUAT)) | (W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC)))
      Quaternion=1;
  }
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  else if(arg == timSdCardLoggingId){
    SD_CardLogging= 1;
  }
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
  else{
    ALLMEMS2_PRINTF("wrong timer : %ld\n",(uint32_t)arg);
  }
  if( semRun ) osSemaphoreRelease(semRun);
}


static int audioInProgress = 0 ;

int startProc(msgType_t type,uint32_t period)
{
  msgData_t msg;
  msg.type         = SET_HOST_LINK_TYPE;
  msg.HostLinkType = DEFAULT_HOST_LINK;
  osTimerId id     = NULL;      
  switch (type)
  {
    case BATTERY_INFO:
      if (!timBatId) 
        timBatId = osTimerCreate (osTimer(TimerBatHandle), osTimerPeriodic, NULL);
      id = timBatId;
      break;
    case BATTERY_PLUG:
      if (!timBattPlugId) 
        timBattPlugId = osTimerCreate (osTimer(TimerBattPlugHandle), osTimerPeriodic, NULL);
      id = timBattPlugId;
      break;
    case ENV:
      if (!timEnvId) 
        timEnvId = osTimerCreate (osTimer(TimerEnvHandle), osTimerPeriodic, NULL);
      if(!TargetBoardFeatures.EnvSensorEnabled)
        enableEnvSensors(); 
      msg.HostLinkType  = ENV_HOST_LINK;
      id = timEnvId;
       break;
    case QUAT:
      if (!timQuatId) 
        timQuatId = osTimerCreate (osTimer(TimerQuatHandle),osTimerPeriodic, NULL);
      if(!TargetBoardFeatures.MotionSensorEnabled)
        enableMotionSensors();
      msg.HostLinkType  = MOTION_HOST_LINK;
      id = timQuatId;
      break;
    case MOTION:
      if (!timMotionId) 
        timMotionId = osTimerCreate (osTimer(TimerMotionHandle),osTimerPeriodic, NULL);
      if(!TargetBoardFeatures.MotionSensorEnabled)
        enableMotionSensors();
      msg.HostLinkType  = MOTION_HOST_LINK;
      id = timMotionId;
      break;
    case COMPASS:
      if (!timCompassId) 
        timCompassId = osTimerCreate (osTimer(TimerCompassHandle),osTimerPeriodic, NULL);
      if(!TargetBoardFeatures.MotionSensorEnabled)
        enableMotionSensors();
      msg.HostLinkType  = MOTION_HOST_LINK;
      id = timCompassId;
      break;
    case AUDIO_LEV:
      if (!timAudioLevId) 
        timAudioLevId = osTimerCreate (osTimer(TimerAudioLevHandle),osTimerPeriodic, NULL);
      id = timAudioLevId;
      PowerCtrlLock();
      msg.HostLinkType  = AUDIO_HOST_LINK;
      audioInProgress |= 0x1 ;
      break;
    case AUDIO_LOC:
      if (!timAudioLocId) 
        timAudioLocId = osTimerCreate (osTimer(TimerAudioLocHandle),osTimerPeriodic, NULL);
      id = timAudioLocId;
      PowerCtrlLock();
      msg.HostLinkType  = AUDIO_HOST_LINK;
      audioInProgress |= 0x2 ;
      break;
    case AUDIO_BV:
      PowerCtrlLock();
      audioInProgress |= 0x4 ;
      msg.HostLinkType  = AUDIO_HOST_LINK;
      break;
    case CARRY:
       if (!timCarryId) 
        timCarryId    = osTimerCreate (osTimer(TimerCarryHandle),osTimerPeriodic, NULL);
      MOTION_SENSOR_Enable( ACCELERO_INSTANCE, MOTION_ACCELERO );
      id = timCarryId;
      break;
    case GESTURE:
      if (!timGestureId) 
        timGestureId  = osTimerCreate (osTimer(TimerGestureHandle),osTimerPeriodic, NULL);
      MOTION_SENSOR_Enable( ACCELERO_INSTANCE, MOTION_ACCELERO );
      id = timGestureId;
      break;
    case ACTIVITY:
     if (!timActivityId) 
        timActivityId = osTimerCreate (osTimer(TimerActivityHandle),osTimerPeriodic, NULL);
      MOTION_SENSOR_Enable( ACCELERO_INSTANCE, MOTION_ACCELERO );
      id = timActivityId;
      break;
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING          
     case SD_CARD_LOGGING:
       if (!timSdCardLoggingId) 
         timSdCardLoggingId = osTimerCreate (osTimer(TimerSdRecordingHandle), osTimerPeriodic, NULL);
       id = timSdCardLoggingId;
       break;
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */ 
    default :
      ALLMEMS2_PRINTF("wrong type : %d\n",type);
      break;
  }
  if (id){
    if  (osTimerStart (id, period) != osOK){
      ALLMEMS2_PRINTF("failed starting timer\n");
    }

  }
  SendMsgToHost(&msg);
  return 0;
}

int stopProc(msgType_t type)
{
  msgData_t msg;
  msg.type          = SET_HOST_LINK_TYPE;
  msg.HostLinkType  = DEFAULT_HOST_LINK;
  osTimerId id = NULL;      
  switch (type)
  {
    case BATTERY_INFO:
      id           = timBatId;
      timBatId     = NULL;
      break;
    case BATTERY_PLUG:
      id           = timBattPlugId;
      timBattPlugId= NULL;
      break;
    case ENV:
      id           = timEnvId;
      timEnvId     = NULL;
      if(TargetBoardFeatures.EnvSensorEnabled)
        disableEnvSensors();
      break;
    case QUAT:
      id           = timQuatId;
      timQuatId    = NULL;
      if(TargetBoardFeatures.MotionSensorEnabled)
        disableMotionSensors();
      break;
    case MOTION:
      id            = timMotionId;
      timMotionId   = NULL;
      if(TargetBoardFeatures.MotionSensorEnabled)
        disableMotionSensors();
      break;
    case COMPASS:
      id            = timCompassId;
      timCompassId  = NULL;
      if(TargetBoardFeatures.MotionSensorEnabled)
        disableMotionSensors();
      break;
    case AUDIO_LEV:
      id            = timAudioLevId;
      if (audioInProgress&0x1) PowerCtrlUnLock();
      timAudioLevId = NULL;
      audioInProgress &= 0x2+0x4 ;
      break;
    case AUDIO_LOC:
      id             = timAudioLocId;
      timAudioLocId  = NULL;
      if (audioInProgress&0x2) PowerCtrlUnLock();
      audioInProgress &= 0x1+0x4 ;
      break;
    case AUDIO_BV:
      if (audioInProgress&0x4) PowerCtrlUnLock();
      audioInProgress &= 0x1+0x2 ;
      break;
    case CARRY:
      id            = timCarryId;
      timCarryId    = NULL;
      MOTION_SENSOR_Disable( ACCELERO_INSTANCE, MOTION_ACCELERO );
      break;
    case GESTURE:
      id            = timGestureId;
      timGestureId  = NULL;
      MOTION_SENSOR_Disable( ACCELERO_INSTANCE, MOTION_ACCELERO );
      break;
    case ACTIVITY:
      id            = timActivityId;
      timActivityId = NULL;
      MOTION_SENSOR_Disable( ACCELERO_INSTANCE, MOTION_ACCELERO );
      break;
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING          
    case SD_CARD_LOGGING:
      id                 = timSdCardLoggingId;
      timSdCardLoggingId = NULL;
      break;
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */ 
    default :
      break;
  }
  if (id){
    if  (osTimerStop (id) != osOK){
      ALLMEMS2_PRINTF("could not stop timer\n");
    }
    if (osTimerDelete (id) != osOK)  {
      ALLMEMS2_PRINTF("could not delete timer\n");
    }
  }
  SendMsgToHost(&msg);
  return 0;
}

/**
  * @brief  This function sets the ACC FS to 2g
  * @param  None
  * @retval None
  */
void Set2GAccelerometerFullScale(void)
{
  /* Set Full Scale to +/-2g */
  MOTION_SENSOR_SetFullScale(ACCELERO_INSTANCE,MOTION_ACCELERO,2.0f);
  
  /* Read the Acc Sensitivity */
  MOTION_SENSOR_GetSensitivity(ACCELERO_INSTANCE,MOTION_ACCELERO,&sensitivity);
  sensitivity_Mul = sensitivity* ((float) FROM_MG_TO_G);
}

/**
  * @brief  This function dsets the ACC FS to 4g
  * @param  None
  * @retval None
  */
void Set4GAccelerometerFullScale(void)
{
  /* Set Full Scale to +/-4g */
  MOTION_SENSOR_SetFullScale(ACCELERO_INSTANCE,MOTION_ACCELERO,4.0f);

  /* Read the Acc Sensitivity */
  MOTION_SENSOR_GetSensitivity(ACCELERO_INSTANCE,MOTION_ACCELERO,&sensitivity);
  sensitivity_Mul = sensitivity* ((float) FROM_MG_TO_G);
}


/**
  * @brief  Callback for user button
  * @param  None
  * @retval None
  */
static void ButtonCallback(void)
{
#ifdef  ENABLE_SHUT_DOWN_MODE
  if ((!hciProcessEnable))
  {
    MCU_PowerSaveExit();
    return;
  }  
#endif /* ENABLE_SHUT_DOWN_MODE */
  /* Only if connected */
  if(connected) {
    static uint32_t HowManyButtonPress=0;
    static uint32_t tickstart=0;
    uint32_t tickstop;

    if(!tickstart)
      tickstart = HAL_GetTick();

    tickstop = HAL_GetTick();

    if((tickstop-tickstart)>2000) {
      HowManyButtonPress=0;
      tickstart=tickstop;
    }

    if(TargetBoardFeatures.MotionFXIsInitalized)
    {
      if((HowManyButtonPress+1)==BLUEMSYS_N_BUTTON_PRESS)
      {
        ForceReCalibration=1;
        HowManyButtonPress=0;
      }
      else
      {
        HowManyButtonPress++;
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM))
        {
           BytesToWrite = sprintf((char *)BufferToWrite, "%ld in %ldmS Reset Calib\r\n",3-HowManyButtonPress,2000-(tickstop-tickstart));
           Term_Update(BufferToWrite,BytesToWrite);
        }
        else
        {
          ALLMEMS2_PRINTF("%ld in %ldmS Reset Calib\r\n",3-HowManyButtonPress,2000-(tickstop-tickstart));
        }
      }
    }
    else
    {
      ALLMEMS2_PRINTF("UserButton Pressed\r\n");
    }
  }
}

/**
  * @brief  Reset the magneto calibration 
  * @param  None
  * @retval None
  */
static void ReCalibration(void)
{
  /* Only if connected */
  if(connected) {
    /* Reset the Compass Calibration */
    isCal=0;
    MFX_MagCal_output_t mag_cal_test;

    /* Notifications of Compass Calibration */
    Config_Notify(FEATURE_MASK_SENSORFUSION_SHORT,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
    Config_Notify(FEATURE_MASK_ECOMPASS,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);

    /* Reset the Calibration */
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite, "\nForce ReCalibration\n\r");
       Term_Update(BufferToWrite,BytesToWrite);
    } else
      ALLMEMS2_PRINTF("\nForce ReCalibration\n\r");
    {
       ResetCalibrationInMemory();
    }

    /* Enable magnetometer calibration */
    MotionFX_manager_MagCal_start(SAMPLE_PERIOD);
    MotionFX_MagCal_getParams(&mag_cal_test);
  }
}

void  AccEvent_Msg(AccEventType Event)
{
  msgData_t msg;
  msg.type  = ACC;
  msg.acc   = Event;
  SendMsgToHost(&msg);
}
void  AccStepEvent_Msg(uint16_t stepCnt)
{
  msgData_t msg;
  msg.type    = ACC_STEP;
  msg.stepCnt = stepCnt;
  SendMsgToHost(&msg);
}

/**
  * @brief  Send Notification where there is a interrupt from MEMS
  * @param  None
  * @retval None
  */
static void MEMSCallback(void)
{
//  ACCELERO_Event_Status_t status;
//  
//  BSP_ACCELERO_Get_Event_Status_Ext(TargetBoardFeatures.HandleAccSensor,&status);
//
//#ifdef  ENABLE_SHUT_DOWN_MODE
//  if ((!hciProcessEnable)&&(status.DoubleTapStatus))
//  {
//    MCU_PowerSaveExit();
//    return;
//  }  
//#endif /* ENABLE_SHUT_DOWN_MODE */
  
  MOTION_SENSOR_Event_Status_t status;
  
  MOTION_SENSOR_Get_Event_Status(ACCELERO_INSTANCE,&status);
  
  
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER)) ||
	  (W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS)) )
  {
    /* Check if the interrupt is due to Pedometer */
    if(status.StepStatus != 0) {
      PedometerStepCount = GetStepHWPedometer();
       if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_PEDOMETER))
        AccStepEvent_Msg(PedometerStepCount);
    }
  }

  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_FREE_FALL)) ||
      (W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS)) )
  {
    /* Check if the interrupt is due to Free Fall */
    if(status.FreeFallStatus != 0) {
      AccEvent_Msg(ACC_FREE_FALL);
    }
  }
  
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_SINGLE_TAP)) ||
      (W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS)) )
  {
    /* Check if the interrupt is due to Single Tap */
    if(status.TapStatus != 0) {
      AccEvent_Msg(ACC_SINGLE_TAP);
    }
  }

  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_DOUBLE_TAP)) ||
      (W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS)) )
  {
    /* Check if the interrupt is due to Double Tap */
    if(status.DoubleTapStatus != 0) {
      AccEvent_Msg(ACC_DOUBLE_TAP);
    }
  }

  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_TILT)) ||
      (W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS)) )
  {
    /* Check if the interrupt is due to Tilt */
    if(status.TiltStatus != 0) {
      AccEvent_Msg(ACC_TILT);
    }
  }
  
  if( (W2ST_CHECK_HW_FEATURE(W2ST_HWF_6DORIENTATION)) ||
      (W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS)) )
  {
    /* Check if the interrupt is due to 6D Orientation */
    if(status.D6DOrientationStatus != 0) {
      AccEventType Orientation = GetHWOrientation6D();
      AccEvent_Msg(Orientation);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_WAKE_UP)) {
    /* Check if the interrupt is due to Wake Up */
    if(status.WakeUpStatus != 0) {
      AccEvent_Msg(ACC_WAKE_UP);
    }
  }

  if(W2ST_CHECK_HW_FEATURE(W2ST_HWF_MULTIPLE_EVENTS))
  {
    AccStepEvent_Msg(PedometerStepCount);
  }
}
/**
  * @brief  Send Motion Data Acc/Mag/Gyro to BLE
  * @param  None
  * @retval None
  */
static void SendMotionData(void)
{
  MOTION_SENSOR_Axes_t ACC_Value;
  MOTION_SENSOR_Axes_t GYR_Value;
  MOTION_SENSOR_Axes_t MAG_Value;
  msgData_t msg;
  
  /* Read the Acc values */
  //BSP_ACCELERO_Get_Axes(TargetBoardFeatures.HandleAccSensor,&ACC_Value);
  MOTION_SENSOR_GetAxes(ACCELERO_INSTANCE,MOTION_ACCELERO,&ACC_Value);

  /* Read the Magneto values */
  //BSP_MAGNETO_Get_Axes(TargetBoardFeatures.HandleMagSensor,&MAG_Value);
  MOTION_SENSOR_GetAxes(MAGNETO_INSTANCE,MOTION_MAGNETO, &MAG_Value);

  /* Read the Gyro values */
  //BSP_GYRO_Get_Axes(TargetBoardFeatures.HandleGyroSensor,&GYR_Value);
  MOTION_SENSOR_GetAxes(GYRO_INSTANCE,MOTION_GYRO, &GYR_Value);
  msg.type    = MOTION;
  msg.motion.acc  = ACC_Value ;
  msg.motion.gyr  = GYR_Value;
  msg.motion.mag  = MAG_Value;
  SendMsgToHost(&msg);
}

/* Code for MotionFX integration - Star Section */

/* @brief  MotionFX Working function
 * @param  None
 * @retval None
 */
static void ComputeQuaternions(void)
{
  static MOTION_SENSOR_Axes_t quat_axes[SEND_N_QUATERNIONS];
  
  static int32_t calibIndex =0;
  static int32_t CounterFX  =0;
  static int32_t CounterEC  =0;
  
  MOTION_SENSOR_AxesRaw_t ACC_Value_Raw;
  MOTION_SENSOR_Axes_t GYR_Value;
  MOTION_SENSOR_Axes_t MAG_Value;

  MFX_MagCal_input_t mag_data_in;

  msgData_t msg;

  /* Increment the Counter */
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC)) {
    CounterEC++;
  } else {
    CounterFX++;
  }

  /* Read the Acc RAW values */
  //BSP_ACCELERO_Get_AxesRaw(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MOTION_SENSOR_GetAxesRaw(ACCELERO_INSTANCE,MOTION_ACCELERO,&ACC_Value_Raw);

  /* Read the Magneto values */
  //BSP_MAGNETO_Get_Axes(TargetBoardFeatures.HandleMagSensor,&MAG_Value);
  MOTION_SENSOR_GetAxes(MAGNETO_INSTANCE,MOTION_MAGNETO,&MAG_Value);

  /* Read the Gyro values */
  //BSP_GYRO_Get_Axes(TargetBoardFeatures.HandleGyroSensor,&GYR_Value);
  MOTION_SENSOR_GetAxes(GYRO_INSTANCE,MOTION_GYRO,&GYR_Value);
      
  /* Check if is calibrated */
  if(isCal!=0x01){
    /* Run Compass Calibration @ 25Hz */
    calibIndex++;
    if (calibIndex == 4){
      calibIndex = 0;

      mag_data_in.mag[0]= MAG_Value.x * FROM_MGAUSS_TO_UT50;
      mag_data_in.mag[1]= MAG_Value.y * FROM_MGAUSS_TO_UT50;
      mag_data_in.mag[2]= MAG_Value.z * FROM_MGAUSS_TO_UT50;
      mag_data_in.time_stamp = mag_time_stamp;
      mag_time_stamp += SAMPLE_PERIOD;
      MotionFX_manager_MagCal_run(&mag_data_in, &magOffset);
      
      /* Control the calibration status */
      if( (magOffset.cal_quality == MFX_MAGCALOK) ||
          (magOffset.cal_quality == MFX_MAGCALGOOD) )
      {
        isCal= 1;
        
        MAG_Offset.x= (int32_t)(magOffset.hi_bias[0] * FROM_UT50_TO_MGAUSS);
        MAG_Offset.y= (int32_t)(magOffset.hi_bias[1] * FROM_UT50_TO_MGAUSS);
        MAG_Offset.z= (int32_t)(magOffset.hi_bias[2] * FROM_UT50_TO_MGAUSS);
        
        /* Disable magnetometer calibration */
        MotionFX_manager_MagCal_stop(SAMPLE_PERIOD);
      }

      if(isCal == 0x01){
        if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
          BytesToWrite = sprintf((char *)BufferToWrite, "Compass Calibrated\n\r");
          Term_Update(BufferToWrite,BytesToWrite);
        } else {
          ALLMEMS2_PRINTF("Compass Calibrated\n\r");
        }

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
        //if( (!IsSdMemsRecording) && (!IsSdAudioRecording))
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
        {
          /* Switch on the Led */
          LedOnTargetPlatform();
        }
        
        /* Notifications of Compass Calibration */
        Config_Notify(FEATURE_MASK_SENSORFUSION_SHORT,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
        Config_Notify(FEATURE_MASK_ECOMPASS,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
      }
    }
  }else {
    calibIndex=0;
  }

  MotionFX_manager_run(ACC_Value_Raw,GYR_Value,MAG_Value);

  /* Read the quaternions */
  MFX_output_t *MotionFX_Engine_Out = MotionFX_manager_getDataOUT();

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_EC)) {
    /* E-Compass Updated every 0.1 Seconds*/
    if(CounterEC==10) {
      uint16_t Angle = (uint16_t)trunc(100*MotionFX_Engine_Out->heading_9X);
      CounterEC = 0;
      msg.type  = COMPASS;
      msg.angle = Angle;
      SendMsgToHost(&msg);
    }
  } else {
    int32_t QuaternionNumber = (CounterFX>SEND_N_QUATERNIONS) ? (SEND_N_QUATERNIONS-1) : (CounterFX-1);

    /* Scaling quaternions data by a factor of 10000
      (Scale factor to handle float during data transfer BT) */

    /* Save the quaternions values */
    if(MotionFX_Engine_Out->quaternion_9X[3] < 0){
      quat_axes[QuaternionNumber].x = (int32_t)(MotionFX_Engine_Out->quaternion_9X[0] * (-10000));
      quat_axes[QuaternionNumber].y = (int32_t)(MotionFX_Engine_Out->quaternion_9X[1] * (-10000));
      quat_axes[QuaternionNumber].z = (int32_t)(MotionFX_Engine_Out->quaternion_9X[2] * (-10000));
    } else {
      quat_axes[QuaternionNumber].x = (int32_t)(MotionFX_Engine_Out->quaternion_9X[0] * 10000);
      quat_axes[QuaternionNumber].y = (int32_t)(MotionFX_Engine_Out->quaternion_9X[1] * 10000);
      quat_axes[QuaternionNumber].z = (int32_t)(MotionFX_Engine_Out->quaternion_9X[2] * 10000);
    }
      
    /* Every QUAT_UPDATE_MUL_10MS*10 mSeconds Send Quaternions informations via bluetooth */
    if(CounterFX==QUAT_UPDATE_MUL_10MS){
      msg.type  = QUAT;
      memcpy(&(msg.quat),&quat_axes,SEND_N_QUATERNIONS * sizeof(MOTION_SENSOR_Axes_t));
      SendMsgToHost(&msg);
      CounterFX=0;
    }
  }
}

/* Code for MotionFX integration - End Section */

/* Code for MotionAR integration - Start Section */
/**
  * @brief  MotionAR Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionAR(void)
{
  static MAR_output_t ActivityCodeStored = MAR_NOACTIVITY;
  MOTION_SENSOR_AxesRaw_t ACC_Value_Raw;
  msgData_t msg;

  /* Read the Acc RAW values */
  //BSP_ACCELERO_Get_AxesRaw(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MOTION_SENSOR_GetAxesRaw(ACCELERO_INSTANCE,MOTION_ACCELERO,&ACC_Value_Raw);

  MotionAR_manager_run(ACC_Value_Raw, TimeStamp);

  if(ActivityCodeStored!=ActivityCode){
    ActivityCodeStored = ActivityCode;
    msg.type           = ACTIVITY;
    msg.activity       = ActivityCode ;
    SendMsgToHost(&msg);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: AR=%d\r\n",ActivityCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      ALLMEMS2_PRINTF("Sending: AR=%d\r\n",ActivityCode);
    }
  }
}
/* Code for MotionAR integration - End Section */

/* Code for MotionCP integration - Start Section */
/**
  * @brief  MotionCP Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionCP(void)
{  
  static MCP_output_t CarryPositionCodeStored = MCP_UNKNOWN;
  MOTION_SENSOR_AxesRaw_t ACC_Value_Raw;
  msgData_t msg;

  /* Read the Acc RAW values */
  //BSP_ACCELERO_Get_AxesRaw(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MOTION_SENSOR_GetAxesRaw(ACCELERO_INSTANCE,MOTION_ACCELERO,&ACC_Value_Raw);
  MotionCP_manager_run(ACC_Value_Raw);

  if(CarryPositionCodeStored!=CarryPositionCode){
    CarryPositionCodeStored = CarryPositionCode;
    msg.type            = CARRY;
    msg.carry           = CarryPositionCode ;
    SendMsgToHost(&msg);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: CP=%d\r\n",CarryPositionCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      ALLMEMS2_PRINTF("Sending: CP=%d\r\n",CarryPositionCode);
    }
  }
}
/* Code for MotionCP integration - End Section */

/* Code for MotionGR integration - Start Section */
/**
  * @brief  MotionGR Working function
  * @param  None
  * @retval None
  */
static void ComputeMotionGR(void)
{
  static MGR_output_t GestureRecognitionCodeStored = MGR_NOGESTURE;
  MOTION_SENSOR_AxesRaw_t ACC_Value_Raw;
  msgData_t msg;

  /* Read the Acc RAW values */
  //BSP_ACCELERO_Get_AxesRaw(TargetBoardFeatures.HandleAccSensor,&ACC_Value_Raw);
  MOTION_SENSOR_GetAxesRaw(ACCELERO_INSTANCE,MOTION_ACCELERO,&ACC_Value_Raw);
  MotionGR_manager_run(ACC_Value_Raw);

  if(GestureRecognitionCodeStored!=GestureRecognitionCode){
    GestureRecognitionCodeStored = GestureRecognitionCode;
    msg.type        = GESTURE;
    msg.gesture     = GestureRecognitionCode ;
    SendMsgToHost(&msg);

    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Sending: GR=%d\r\n",GestureRecognitionCode);
       Term_Update(BufferToWrite,BytesToWrite);
    } else {
      ALLMEMS2_PRINTF("Sending: GR=%d\r\n",GestureRecognitionCode);
    }
  }
}
/* Code for MotionGR integration - End Section */

/**
* @brief  User function that is called when 1 ms of PDM data is available.
* @param  none
* @retval None
*/
void AudioProcess(void)
{
  /*for L4 PDM to PCM conversion is performed in hardware by DFSDM peripheral*/ 
  
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
  if(SD_LogAudio_Enabled)
  {
    AudioProcess_SD_Recording();
  } else
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
  {
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL))
    {
      AudioProcess_DB_Noise();
    }
  }
}


/**
* @brief  User function that is called when 1 ms of PDM data is available.
* @param  none
* @retval None
*/
void AudioProcess_DB_Noise(void)
{
  int32_t i;
  int32_t NumberMic;
  
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_AUDIO_LEVEL)) {
    for(i = 0; i < 16; i++){
      for(NumberMic=0;NumberMic<AUDIO_IN_CHANNELS;NumberMic++) {
        RMS_Ch[NumberMic] += (float)((int16_t)PCM_Buffer[i*AUDIO_IN_CHANNELS+NumberMic] * ((int16_t)PCM_Buffer[i*AUDIO_IN_CHANNELS+NumberMic]));
      }
    }
  }
}

/**
  * @brief  Send Audio Level Data (Ch1) to BLE
  * @param  None
  * @retval None
  */
static void SendAudioLevelData(void)
{
  int32_t NumberMic;
  uint16_t DBNOISE_Value_Ch[AUDIO_IN_CHANNELS];
  msgData_t msg;
  
  for(NumberMic=0;NumberMic<(AUDIO_IN_CHANNELS);NumberMic++) {
    DBNOISE_Value_Ch[NumberMic] = 0;

    RMS_Ch[NumberMic] /= (16.0f*DEFAULT_AUDIO_LEV_PERIOD);

    DBNOISE_Value_Ch[NumberMic] = (uint16_t)((120.0f - 20 * log10f(32768 * (1 + 0.25f * (AUDIO_VOLUME_INPUT /*AudioInVolume*/ - 4))) + 10.0f * log10f(RMS_Ch[NumberMic])) * 0.3f + DBNOISE_Value_Old_Ch[NumberMic] * 0.7f);
    DBNOISE_Value_Old_Ch[NumberMic] = DBNOISE_Value_Ch[NumberMic];
    RMS_Ch[NumberMic] = 0.0f;
  }
  msg.type  = AUDIO_LEV;
  memcpy(&(msg.DBNOISE_Value_Ch),&DBNOISE_Value_Ch,AUDIO_IN_CHANNELS* sizeof(uint16_t));
  SendMsgToHost(&msg);
}

/**
* @brief  Half Transfer user callback, called by BSP functions.
* @param  None
* @retval None
*/
void BSP_AUDIO_IN_HalfTransfer_CallBack(uint32_t Instance)
{
  AudioProcess();
}

/**
* @brief  Transfer Complete user callback, called by BSP functions.
* @param  None
* @retval None
*/
void BSP_AUDIO_IN_TransferComplete_CallBack(uint32_t Instance)
{
  AudioProcess();
}

/**
  * @brief  Read The Environmental Data (Temperature/Pressure/Humidity)
  * @param  int32_t *PressToSend pointer to Press Value
  * @param  uint16_t *HumToSend  pointer to Humidity Value
  * @param  int16_t *Temp1ToSend pointer to Temperature1 Value
  * @param  int16_t *Temp2ToSend pointer to Temperature2 Value
  * @retval None
  */
void ReadEnvironmentalData(int32_t *PressToSend,uint16_t *HumToSend,int16_t *Temp1ToSend,int16_t *Temp2ToSend)
{
  float SensorValue;
  int32_t decPart, intPart;
  
  *PressToSend=0;
  *HumToSend=0;
  *Temp2ToSend=0,*Temp1ToSend=0;

  /* Read Humidity */
  ENV_SENSOR_GetValue(HUMIDITY_INSTANCE,ENV_HUMIDITY,&SensorValue);
  MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
  *HumToSend = intPart*10+decPart;

  /* Read Temperature for sensor 1 */
  ENV_SENSOR_GetValue(TEMPERATURE_INSTANCE_1,ENV_TEMPERATURE,&SensorValue);
  MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
  *Temp1ToSend = intPart*10+decPart;
#ifdef ONE_SHOT
  ENV_SENSOR_Set_One_Shot(HUMIDITY_INSTANCE);
#endif
  
  /* Read Pressure */
  ENV_SENSOR_GetValue(PRESSURE_INSTANCE,ENV_PRESSURE,&SensorValue);
  MCR_BLUEMS_F2I_2D(SensorValue, intPart, decPart);
  *PressToSend=intPart*100+decPart;

  /* Read Temperature for sensor 2 */
  ENV_SENSOR_GetValue(TEMPERATURE_INSTANCE_2,ENV_TEMPERATURE,&SensorValue);
  MCR_BLUEMS_F2I_1D(SensorValue, intPart, decPart);
  *Temp2ToSend = intPart*10+decPart;
#ifdef ONE_SHOT
  ENV_SENSOR_Set_One_Shot(PRESSURE_INSTANCE);
#endif
}

/**
  * @brief  Send Environmetal Data (Temperature/Pressure/Humidity) to BLE
  * @param  None
  * @retval None
  */
static void SendEnvironmentalData(void)
{
  msgData_t msg;
  
  /* Notifications of Compass Calibration status*/
  if(FirstConnectionConfig) {
    Config_Notify(FEATURE_MASK_SENSORFUSION_SHORT,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
    Config_Notify(FEATURE_MASK_ECOMPASS,W2ST_COMMAND_CAL_STATUS,isCal ? 100: 0);
#ifdef ALLMEMS2_DEBUG_NOTIFY_TRAMISSION
     if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"\r\nCal=%d\r\n\r\n",isCal);
       Term_Update(BufferToWrite,BytesToWrite);
     } else {
      ALLMEMS2_PRINTF("\r\nCal=%d\r\n",isCal);
     }
#endif /* ALLMEMS2_DEBUG_NOTIFY_TRAMISSION */
    FirstConnectionConfig=0;
    
#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
    //if( (!IsSdMemsRecording) && (!IsSdAudioRecording))
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */
    {
      /* Switch on/off the LED according to calibration */
      if(isCal){
        LedOnTargetPlatform();
      } else {
        LedOffTargetPlatform();
      }
    }
  }

  /* Pressure, Humidity, and Temperatures */
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_ENV)) {
    int32_t PressToSend;
    uint16_t HumToSend;
    int16_t Temp2ToSend,Temp1ToSend;
    
    /* Read all the Environmental Sensors */
    ReadEnvironmentalData(&PressToSend,&HumToSend, &Temp1ToSend,&Temp2ToSend);

#ifdef ALLMEMS2_DEBUG_NOTIFY_TRAMISSION
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
      BytesToWrite = sprintf((char *)BufferToWrite,"Sending: ");
      Term_Update(BufferToWrite,BytesToWrite);
      BytesToWrite = sprintf((char *)BufferToWrite,"Press=%ld ",PressToSend);
      Term_Update(BufferToWrite,BytesToWrite);
      BytesToWrite = sprintf((char *)BufferToWrite,"Hum=%d ",HumToSend);
      Term_Update(BufferToWrite,BytesToWrite);
      BytesToWrite = sprintf((char *)BufferToWrite,"Temp=%d ",Temp1ToSend);
      Term_Update(BufferToWrite,BytesToWrite);
      BytesToWrite = sprintf((char *)BufferToWrite,"Temp2=%d ",Temp2ToSend);
      Term_Update(BufferToWrite,BytesToWrite);
      BytesToWrite = sprintf((char *)BufferToWrite,"\r\n");
      Term_Update(BufferToWrite,BytesToWrite);
    } else {
      ALLMEMS2_PRINTF("Sending: ");
      ALLMEMS2_PRINTF("Press=%ld ",PressToSend);
      ALLMEMS2_PRINTF("Hum=%d ",HumToSend);
      ALLMEMS2_PRINTF("Temp1=%d ",Temp1ToSend);
      ALLMEMS2_PRINTF("Temp2=%d ",Temp2ToSend);
      ALLMEMS2_PRINTF("\r\n");
    }
#endif /* ALLMEMS2_DEBUG_NOTIFY_TRAMISSION */

    msg.type      = ENV;
    msg.env.press = PressToSend;
    msg.env.hum   = HumToSend;
    msg.env.temp2 = Temp2ToSend;
    msg.env.temp1 = Temp1ToSend;
    SendMsgToHost(&msg);
  }
}

/**
  * @brief  Send Battery Info Data (Voltage/Level/Current/Soc) to BLE
  * @param  None
  * @retval None
  */
static void SendBatteryInfoData(void)
{
  msgData_t msg;
  
  uint32_t Status;  
  stbc02_State_TypeDef BC_State = {(stbc02_ChgState_TypeDef)0, ""};
  uint32_t BatteryLevel;
  uint32_t Voltage;
  int32_t Current= 0;
  
  /* Read the Battery Charger voltage value */
  BSP_BC_GetVoltageAndLevel(&Voltage,&BatteryLevel);
  
  /* Read the Battery Status */
  BSP_BC_GetState(&BC_State);
  
  switch(BC_State.Id) {
    case NotValidInput:
      Status = 0x01; /* Discharging */
    break;
    case VbatLow:
      Status = 0x00; /* Low Battery */
    break;
    case EndOfCharge:
      Status = 0x02; /* End of Charging == Plugged not Charging */
    break;
    case ChargingPhase:
      Status = 0x03; /* Charging */
    break;
    default:
      /* All the Remaing Battery Status */
      Status = 0x04; /* Unknown */
  }
  
  /* No info for Current */
  Current = 0x8000;

  /* Battery Informations */
  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_BATTERY_FEATURES_EVENT)) {

    msg.type                    = BATTERY_INFO;
    msg.batteryInfo.voltage     = Voltage;
    msg.batteryInfo.level       = BatteryLevel;
    msg.batteryInfo.soc_status  = Status;
    msg.batteryInfo.current     = Current;
    
    SendMsgToHost(&msg);
  }
  
#ifdef ALLMEMS2_DEBUG_NOTIFY_TRAMISSION
     if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
       BytesToWrite = sprintf((char *)BufferToWrite,"Battery Report: Charge= %ld%% Voltage=%ld mV BC_State= %d\r\n", BatteryLevel, Voltage, BC_State.Id);
       Term_Update(BufferToWrite,BytesToWrite);
     } else {
       ALLMEMS2_PRINTF("Battery Report: Charge= %ld%% Voltage=%ld mV BC_State= %d\r\n", BatteryLevel, Voltage, BC_State.Id);
     }
#endif /* ALLMEMS2_DEBUG_NOTIFY_TRAMISSION */
}

/**
  * @brief  CRC init function.
  * @param  None
  * @retval None
  */
static void MX_CRC_Init(void)
{
  hcrc.Instance = CRC;

  if (HAL_CRC_Init(&hcrc) != HAL_OK)
  {
    Error_Handler();
  }
}

/** @brief Initialize the BlueNRG Stack
 * @param None
 * @retval None
 */
static void Init_BlueNRG_Stack(void)
{
  char BoardName[8];
  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;
  int ret;
  uint8_t data_len_out;
  uint8_t  hwVersion;
  uint16_t fwVersion;
  
  for(int i=0; i<7; i++)
    BoardName[i]= NodeName[i+1];
    
  BoardName[7]= 0;

  /* Initialize the BlueNRG SPI driver */
  hci_init(APP_UserEvtRx, NULL);
  
  /* get the BlueNRG HW and FW versions */
  getBlueNRG2_Version(&hwVersion, &fwVersion);
  
  aci_hal_read_config_data(0x80, &data_len_out, bdaddr);
  
  if ((bdaddr[5] & 0xC0) != 0xC0) {
    ALLMEMS2_PRINTF("\r\nStatic Random address not well formed.\r\n");
    while(1);
  }
  
  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, data_len_out,
                                  bdaddr); 
  
  /* Sw reset of the device */
  hci_reset();
  HAL_Delay(1000);

  ret = aci_gatt_init();    
  if(ret){
     ALLMEMS2_PRINTF("\r\nGATT_Init failed\r\n");
     goto fail;
  }

  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, 0, 0x07, &service_handle, &dev_name_char_handle, &appearance_char_handle);

  if(ret != BLE_STATUS_SUCCESS){
     ALLMEMS2_PRINTF("\r\nGAP_Init failed\r\n");
     goto fail;
  }

  ret = aci_gatt_update_char_value(service_handle, dev_name_char_handle, 0,
                                   7/*strlen(BoardName)*/, (uint8_t *)BoardName);

  if(ret){
     ALLMEMS2_PRINTF("\r\naci_gatt_update_char_value failed\r\n");
    while(1);
  }

  ret = aci_gap_set_authentication_requirement(BONDING,
                                               MITM_PROTECTION_REQUIRED,
                                               SC_IS_SUPPORTED,
                                               KEYPRESS_IS_NOT_SUPPORTED,
                                               7, 
                                               16,
                                               USE_FIXED_PIN_FOR_PAIRING,
                                               123456,
                                               0x00);
  
  if (ret != BLE_STATUS_SUCCESS) {
     ALLMEMS2_PRINTF("\r\nGAP setting Authentication failed\r\n");
     goto fail;
  }
  
  ALLMEMS2_PRINTF("\r\nSERVER: BLE Stack Initialized \r\n"
         "\t\tHWver= %d.%d\r\n"
         "\t\tFWver= %d.%d.%c\r\n"
         "\t\tBoardName= %s\r\n"
         "\t\tBoardMAC = %x:%x:%x:%x:%x:%x\r\n\n",
         ((hwVersion>>4)&0x0F),(hwVersion&0x0F),
         (fwVersion>>8)&0xF,
         (fwVersion>>4)&0xF,
         ('a' + (fwVersion&0xF)),
         BoardName,
         bdaddr[5],bdaddr[4],bdaddr[3],bdaddr[2],bdaddr[1],bdaddr[0]);

  /* Set output power level */
  aci_hal_set_tx_power_level(1,4); /* -2,1 dBm */

  return;

fail:
  return;
}

/** @brief 
  * @param None
  * @retval None
  */
void APP_UserEvtRx(void *pData)
{
  uint32_t i;

  hci_spi_pckt *hci_pckt = (hci_spi_pckt *)pData;

  if(hci_pckt->type == HCI_EVENT_PKT) {
    hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;

    if(event_pckt->evt == EVT_LE_META_EVENT) {
      evt_le_meta_event *evt = (void *)event_pckt->data;

      for (i = 0; i < (sizeof(hci_le_meta_events_table)/sizeof(hci_le_meta_events_table_type)); i++) {
        if (evt->subevent == hci_le_meta_events_table[i].evt_code) {
          hci_le_meta_events_table[i].process((void *)evt->data);
        }
      }
    } else if(event_pckt->evt == EVT_VENDOR) {
      evt_blue_aci *blue_evt = (void*)event_pckt->data;        

      for (i = 0; i < (sizeof(hci_vendor_specific_events_table)/sizeof(hci_vendor_specific_events_table_type)); i++) {
        if (blue_evt->ecode == hci_vendor_specific_events_table[i].evt_code) {
          hci_vendor_specific_events_table[i].process((void *)blue_evt->data);
        }
      }
    } else {
      for (i = 0; i < (sizeof(hci_events_table)/sizeof(hci_events_table_type)); i++) {
        if (event_pckt->evt == hci_events_table[i].evt_code) {
          hci_events_table[i].process((void *)event_pckt->data);
        }
      }
    }
  }
}

/**
 * @brief  Get hardware and firmware version
 *
 * @param  Hardware version
 * @param  Firmware version
 * @retval Status
 */
uint8_t getBlueNRG2_Version(uint8_t *hwVersion, uint16_t *fwVersion)
{
  uint8_t status;
  uint8_t hci_version, lmp_pal_version;
  uint16_t hci_revision, manufacturer_name, lmp_pal_subversion;
  uint8_t DTM_version_major, DTM_version_minor, DTM_version_patch, DTM_variant, BTLE_Stack_version_major, BTLE_Stack_version_minor, BTLE_Stack_version_patch, BTLE_Stack_development;
  uint16_t DTM_Build_Number, BTLE_Stack_variant, BTLE_Stack_Build_Number;


  status = hci_read_local_version_information(&hci_version, &hci_revision, &lmp_pal_version, 
				                              &manufacturer_name, &lmp_pal_subversion);

  if (status == BLE_STATUS_SUCCESS) {
    *hwVersion = hci_revision >> 8;
  }
  else {
    ALLMEMS2_PRINTF("Error= %x \r\n", status);
  }
  
  
  status = aci_hal_get_firmware_details(&DTM_version_major,
                                        &DTM_version_minor,
                                        &DTM_version_patch,
                                        &DTM_variant,
                                        &DTM_Build_Number,
                                        &BTLE_Stack_version_major,
                                        &BTLE_Stack_version_minor,
                                        &BTLE_Stack_version_patch,
                                        &BTLE_Stack_development,
                                        &BTLE_Stack_variant,
                                        &BTLE_Stack_Build_Number);
  
  if (status == BLE_STATUS_SUCCESS) {
    *fwVersion = BTLE_Stack_version_major  << 8;  // Major Version Number
    *fwVersion |= BTLE_Stack_version_minor << 4;  // Minor Version Number
    *fwVersion |= BTLE_Stack_version_patch;       // Patch Version Number
  }
  else {
    ALLMEMS2_PRINTF("Error= %x \r\n", status);
  }
  
    
  return status;
}

/** @brief Initialize all the Custom BlueNRG services
 * @param None
 * @retval None
 */
static void Init_BlueNRG_Custom_Services(void)
{
  int ret;
  
  ret = Add_HW_SW_ServW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS)
  {
     ALLMEMS2_PRINTF("HW & SW Service W2ST added successfully\r\n");
  }
  else
  {
     ALLMEMS2_PRINTF("\r\nError while adding HW & SW Service W2ST\r\n");
  }

  ret = Add_ConsoleW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS)
  {
     ALLMEMS2_PRINTF("Console Service W2ST added successfully\r\n");
  }
  else
  {
     ALLMEMS2_PRINTF("\r\nError while adding Console Service W2ST\r\n");
  }

  ret = Add_ConfigW2ST_Service();
  if(ret == BLE_STATUS_SUCCESS)
  {
     ALLMEMS2_PRINTF("Config  Service W2ST added successfully\r\n");
  }
  else
  {
     ALLMEMS2_PRINTF("\r\nError while adding Config Service W2ST\r\n");
  }
}

/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow : 
  *            System Clock source            = PLL (MSI)
  *            SYSCLK(Hz)                     = 120000000
  *            HCLK(Hz)                       = 120000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 1
  *            APB2 Prescaler                 = 1
  *            MSI Frequency(Hz)              = 4000000
  *            PLL_M                          = 4
  *            PLL_N                          = 60
  *            PLL_R                          = 2
  *            PLL_P                          = 2
  *            PLL_Q                          = 2
  *            Flash Latency(WS)              = 5
  * @param  None
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

    /**Configure the main internal regulator output voltage 
    */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST) != HAL_OK) {
    /* Initialization Error */
    while(1);
  }
  
   /**Configure LSE Drive Capability 
    */
  HAL_PWR_EnableBkUpAccess();

  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|
                                     RCC_OSCILLATORTYPE_LSE  |
                                     RCC_OSCILLATORTYPE_HSE  |
                                     RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 60;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
    /* Initialization Error */
    while(1);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK   |
                                RCC_CLOCKTYPE_SYSCLK |
                                RCC_CLOCKTYPE_PCLK1  |
                                RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) {
    /* Initialization Error */
    while(1);
  }
  
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SAI1   |
                                      RCC_PERIPHCLK_DFSDM1 |
                                      RCC_PERIPHCLK_USB    |
                                      RCC_PERIPHCLK_RTC    |
                                      RCC_PERIPHCLK_SDMMC1 |
                                      RCC_PERIPHCLK_ADC;

  PeriphClkInit.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLLSAI1;
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;  
  PeriphClkInit.Dfsdm1ClockSelection = RCC_DFSDM1CLKSOURCE_PCLK2;  
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
  PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLLP;
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 5;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 96;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV25;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_ADC1CLK|RCC_PLLSAI1_SAI1CLK;  
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) {
    /* Initialization Error */
    while(1);
  }
}

#ifdef ENABLE_SHUT_DOWN_MODE 
/**
  * @brief  This function put the MCU in ShutDown mode
  * @param  None
  * @retval None
  */
void MCU_PowerSave(void)
{
 LedBlinkStop();
}

/**
  * @brief  This function exits the MCU from ShutDown mode
  * @param  None
  * @retval None
  */
void MCU_PowerSaveExit(void)
{
  LedBlinkStart();
}

#endif /* ENABLE_SHUT_DOWN_MODE  */

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
/**
  * @brief  Configure the current date.
  * @param  WeekDay Specifies the RTC Date WeekDay and it can be a value of @ref RTC_WeekDay_Definitions
  * @param  Date    Specifies the RTC Date Month (in BCD format) and it can be a value of @ref RTC_Month_Date_Definitions
  * @param  Month   Specifies the RTC Date and it must be a number between Min_Data = 1 and Max_Data = 31
  * @param  Year    Specifies the RTC Date Year and it must be a number between Min_Data = 0 and Max_Data = 99
  * @retval None
  */
void RTC_DataConfig(uint8_t WeekDay, uint8_t Date, uint8_t Month, uint8_t Year)
{
  RTC_DateTypeDef  sdatestructure;
 
  sdatestructure.WeekDay = WeekDay;
  sdatestructure.Date = Date;
  sdatestructure.Month = Month;
  sdatestructure.Year = Year; 
  
  if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler(); 
  }
}

/**
  * @brief  Configure the current time.
  * @param  Hours   Specifies the RTC Time Hour.
  *                 This parameter must be a number between Min_Data = 0 and Max_Data = 12 if the RTC_HourFormat_12 is selected.
  *                 This parameter must be a number between Min_Data = 0 and Max_Data = 23 if the RTC_HourFormat_24 is selected
  * @param  Minutes Specifies the RTC Time Minutes and it must be a number between Min_Data = 0 and Max_Data = 59 
  * @param  Seconds Specifies the RTC Time Seconds and it must be a number between Min_Data = 0 and Max_Data = 59
  * @retval None
  */
void RTC_TimeConfig(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
{
  RTC_TimeTypeDef  stimestructure;
  
  stimestructure.Hours = Hours;
  stimestructure.Minutes = Minutes;
  stimestructure.Seconds = Seconds;
  stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
  stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
  stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
  
  if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler(); 
  }
}

/**
  * @brief  Configure the RTC Alarm peripheral.
  * @param  StepHour Step value of the hour    for setting alarm
  * @param  StepMin  Step value of the minutes for setting alarm
  * @param  StepSec  Step value of the second  for setting alarm
  * @retval None
  */
void RTC_AlarmConfig(uint8_t StepHour, uint8_t StepMin, uint8_t StepSec)
{
  RTC_TimeTypeDef  stimestructureget;
  RTC_AlarmTypeDef salarmstructure;
  
  uint8_t Overflow= 0;
  uint8_t NewSec= 0x00;
  uint8_t NewMin= 0x00;
  uint8_t NewHour= 0x00;
  
  /* Get the RTC current Time */
  HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BCD);
  
  /* Set Alarm - RTC Alarm Generation: Alarm on Hours, Minutes and Seconds */
  salarmstructure.Alarm = RTC_ALARM_A;
  salarmstructure.AlarmDateWeekDay = RTC_WEEKDAY_MONDAY;
  salarmstructure.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_WEEKDAY;
  salarmstructure.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY;
  salarmstructure.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;
  salarmstructure.AlarmTime.TimeFormat = RTC_HOURFORMAT12_AM;
  
  if(StepSec > 0)
    AddSecOrMin(stimestructureget.Seconds, StepSec, &Overflow, &NewSec);
  else
    NewSec= stimestructureget.Seconds;
  
  StepMin= StepMin + Overflow;
  Overflow= 0;
  if(StepMin > 0)
    AddSecOrMin(stimestructureget.Minutes, StepMin, &Overflow, &NewMin);
  else
    NewMin= stimestructureget.Minutes;
  
  StepHour= StepHour + Overflow;
  if(StepHour > 0)
    AddHours(stimestructureget.Hours, StepHour, &NewHour);
  else
    NewHour= stimestructureget.Hours;  
  
  salarmstructure.AlarmTime.Hours   = NewHour; 
  salarmstructure.AlarmTime.Minutes = NewMin;
  salarmstructure.AlarmTime.Seconds = NewSec;
  
  //ALLMEMS2_PRINTF("New Allarm --> %02x:%02x:%02x\n\r",salarmstructure.AlarmTime.Hours, salarmstructure.AlarmTime.Minutes, salarmstructure.AlarmTime.Seconds);
  BytesToWrite =sprintf((char *)BufferToWrite,"New Allarm --> %02x:%02x:%02x\r\n", salarmstructure.AlarmTime.Hours, salarmstructure.AlarmTime.Minutes, salarmstructure.AlarmTime.Seconds);
  Term_Update(BufferToWrite,BytesToWrite);  

  salarmstructure.AlarmTime.SubSeconds = 0x20;
  
  if(HAL_RTC_SetAlarm_IT(&RtcHandle,&salarmstructure, RTC_FORMAT_BCD) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler(); 
  }
}

/**
  * @brief Evaluates new seconds/minutes value to set the alarm
  * @param CurrentValue Current Value of the seconds/minutes
  * @param AddValue     Step value of the seconds/minutes to set the alarm
  * @param Overflow     Overflow= 1 if CurrentValue + AddValue > 60
  * @param NewValue     New seconds/minutes value to set the alarm
  * @retval None
  */
static void AddSecOrMin(uint8_t CurrentValue, uint8_t AddValue, uint8_t *Overflow, uint8_t *NewValue)
{
  uint8_t Index;
  
  *NewValue= CurrentValue;
  
  for(Index=0; Index<AddValue; Index++)
  {
    if((*NewValue & 0x0F) == 0x09)
    {
      *NewValue= *NewValue + 0x07;
    }
    else
    {
      *NewValue= *NewValue + 0x01;
    }
    
    if(*NewValue == 0x60)
    {
      *NewValue= 0x00;
      *Overflow= *Overflow + 1;
    }
  }
}

/**
  * @brief Evaluates new hours value to set the alarm
  * @param CurrentValue Current value of the hour
  * @param AddValue     Step of the hour for setting the alarm
  * @param Overflow     Overflow= 1 if CurrentValue + AddValue > 24
  * @param NewValue     New value of hour to set the alarm
  * @retval None
  */
static void AddHours(uint8_t CurrentValue, uint8_t AddValue, uint8_t *NewValue)
{
  uint8_t Index;
  
  *NewValue= CurrentValue;
  
  for(Index=0; Index<AddValue; Index++)
  {
    if((*NewValue & 0x0F) == 0x09)
    {
      *NewValue= *NewValue + 0x07;
    }
    else
    {
      *NewValue= *NewValue + 0x01;
    }
    
    if(*NewValue == 0x24)
    {
      *NewValue= 0x00;
    }
  }
}

/**
  * @brief  Alarm callback
  * @param  hrtc : RTC handle
  * @retval None
  */
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
  SD_CardLogging= 1;
  if(semRun) osSemaphoreRelease(semRun); 
}

/**
  * @brief  Get the current data and time value.
  * @param  None
  * @retval None
  */
void RTC_GetCurrentDateTime(void)
{
  /* Get the RTC current Time */
  HAL_RTC_GetTime(&RtcHandle, &CurrentTime, RTC_FORMAT_BIN);
  /* Get the RTC current Date */
  HAL_RTC_GetDate(&RtcHandle, &CurrentDate, RTC_FORMAT_BIN);
} 
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */

/**
  * @brief This function provides accurate delay (in milliseconds) based 
  *        on variable incremented.
  * @note This is a user implementation using WFI state
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
void HAL_Delay(__IO uint32_t Delay)
{
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
  while((HAL_GetTick() - tickstart) < Delay){
    __WFI();
  }
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
  /* User may add here some code to deal with this error */
  while(1){
  }
}

/**
 * @brief  EXTI line detection callback.
 * @param  uint16_t GPIO_Pin Specifies the pins connected EXTI line
 * @retval None
 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{  
    msgData_t msg;
    
  switch(GPIO_Pin){
  case HCI_TL_SPI_EXTI_PIN:  
    hci_tl_lowlevel_isr();
    msg.type  = PROCESS_EVENT;
    SendMsgToHost(&msg);
    break;

  case USER_BUTTON_PIN:
    ButtonPressed = 1;
    if(semRun) osSemaphoreRelease(semRun); 
    break;
    
  /* Power off the board */
//  case POWER_BUTTON_PIN:
//    PowerButtonPressed = 1;
//    if(semRun) {
//      osSemaphoreRelease(semRun);
//    }
//    break;

  /* HW events from LSM6DSOX */
  //case GPIO_PIN_3:
  case GPIO_PIN_2:
    MEMSInterrupt=1;
    if(semRun) osSemaphoreRelease(semRun); 
    break;
    
  case STBC02_CHG_PIN:
      /* For understanding if is under charge or not */
    BSP_BC_ChgPinHasToggled();
    break;
  }
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: ALLMEMS2_PRINTF("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1){
  }
}
#endif

/**
 * @brief  Test if calibration data are available
 * @param  None
 * @retval None
 */
static void MagCalibTest(void)
{
  MFX_MagCal_output_t mag_cal_test;
  
  /* Recall the calibration Credential saved */
  MotionFX_manager_MagCal_start(SAMPLE_PERIOD);
  MotionFX_MagCal_getParams(&mag_cal_test);
    
  if(MagCalibrationData[0]== BLUEMSYS_CHECK_CALIBRATION)
  {
    if( (mag_cal_test.cal_quality == MFX_MAGCALOK) ||
        (mag_cal_test.cal_quality == MFX_MAGCALGOOD) )
    {
      MAG_Offset.x = (int32_t) (mag_cal_test.hi_bias[0] * FROM_UT50_TO_MGAUSS);
      MAG_Offset.y = (int32_t) (mag_cal_test.hi_bias[1] * FROM_UT50_TO_MGAUSS);
      MAG_Offset.z = (int32_t) (mag_cal_test.hi_bias[2] * FROM_UT50_TO_MGAUSS);

      isCal =1;
        
      ALLMEMS2_PRINTF("Magneto Calibration Read\r\n");
    }
    else
    {
      isCal =0;
      ALLMEMS2_PRINTF("Magneto Calibration quality is not good\r\n");
    }
  }
  else
  {
    ALLMEMS2_PRINTF("Magneto Calibration Not present\r\n");
    isCal=0;
  }
  
  if(!isCal)
  {
    MAG_Offset.x = 0;
    MAG_Offset.y = 0;
    MAG_Offset.z = 0;
  }
}


/**
 * @brief  Check if there are a valid Magneto Calibration Values in Memory and read them
 * @param  uint16_t dataSize
 * @param  uint32_t *data
 * @retval unsigned char Success/Not Success
 */
unsigned char ReCallMagnetoCalibrationFromMemory(uint16_t dataSize, uint32_t *data)
{
  /* ReLoad the Magneto Calibration Values from RAM */
  unsigned char Success=0;

  int i;
  
  /* Recall the magneto calibration Credential saved */
  MDM_ReCallGMD(GMD_MAG_CALIBRATION,(void *)&MagCalibrationData);
  
  for(i=0; i<dataSize; i++)
  {
    data[i]= MagCalibrationData[i+1];
  }

  return Success;
}

/**
 * @brief  Save the Magnetometer Calibration Values to Memory
 * @param  uint16_t dataSize
 * @param  uint32_t *data
 * @retval unsigned char Success/Not Success
 */
unsigned char SaveMagnetoCalibrationToMemory(uint16_t dataSize, uint32_t *data)
{
  unsigned char Success=1;
  
  int i;

  /* Reset Before The data in Memory */
  //Success = ResetMagnetoCalibrationInMemory();

  if(Success) {
    /* Store in RAM */
    MagCalibrationData[0] = BLUEMSYS_CHECK_CALIBRATION;
    
    for(i=0; i<dataSize; i++)
    {
      MagCalibrationData[i+1]= data[i];
    }
 
    if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite, "Magneto Calibration will be saved in FLASH\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
    } else {
      ALLMEMS2_PRINTF("Magneto Calibration will be saved in FLASH\r\n");
    }

    MDM_SaveGMD(GMD_MAG_CALIBRATION,(void *)&MagCalibrationData);
    
    NecessityToSaveMetaDataManager=1;
  }

  return Success;
}

/**
 * @brief  Reset the Magnetometer Calibration Values in Memory
 * @param uint32_t *MagnetoCalibration the Magneto Calibration
 * @retval unsigned char Success/Not Success
 */
static unsigned char ResetCalibrationInMemory(void)
{
  /* Reset Calibration Values in RAM */
  unsigned char Success=1;
  int32_t Counter;

  for(Counter=0;Counter<29;Counter++)
    MagCalibrationData[Counter]=0x0;

  if(W2ST_CHECK_CONNECTION(W2ST_CONNECT_STD_TERM)) {
     BytesToWrite = sprintf((char *)BufferToWrite, "Magneto Calibration will be erased in FLASH\r\n");
     Term_Update(BufferToWrite,BytesToWrite);
  } else {
    ALLMEMS2_PRINTF("Magneto Calibration will be erased in FLASH\r\n");
  }
  
  MDM_SaveGMD(GMD_MAG_CALIBRATION,(void *)&MagCalibrationData);

  NecessityToSaveMetaDataManager=1;
  return Success;
}

/**
 * @brief  Check if there are a valid Node Name Values in Memory and read them
 * @param  None
 * @retval unsigned char Success/Not Success
 */
static unsigned char ReCallNodeNameFromMemory(void)
{
  const char DefaultBoardName[7] = {NAME_BLUEMS};
  
  /* ReLoad the Node Name Values from RAM */
  unsigned char Success=0;

  /* Recall the node name Credential saved */
  MDM_ReCallGMD(GMD_NODE_NAME,(void *)&NodeName);
  
  if(NodeName[0] != 0x12)
  {
    NodeName[0]= 0x12;
    
    for(int i=0; i<7; i++)
      NodeName[i+1]= DefaultBoardName[i];
    
    MDM_SaveGMD(GMD_NODE_NAME,(void *)&NodeName);
    NecessityToSaveMetaDataManager=1;
  }

  return Success;
}

#ifdef ALLMEMS2_ENABLE_SD_CARD_LOGGING
/**
 * @brief  SD Card mems logging run
 * @param  None
 * @retval None
 */
static void SdCardMemsRecordingRun(void)
{
  if(!IsSdMemsRecording)
  {
    SD_CardLoggingMemsStart();
    
    if(!IsSdMemsRecording)
    {
      SD_Card_Status= 0;
      SD_CardLoggingStatus_Notify(2, SD_Card_FeaturesMask, SD_Card_StepTime);
    }
  }
  
  if(IsSdMemsRecording)
  {
    if(SD_Card_StepTime > 0)
    {
      SD_CardLogging_StepSeconds= SD_Card_StepTime%60;
      SD_CardLogging_StepMinutes= SD_Card_StepTime/60;
      SD_CardLogging_StepHours=   SD_CardLogging_StepMinutes/60;
      SD_CardLogging_StepMinutes= SD_CardLogging_StepMinutes - SD_CardLogging_StepHours*60;
        
      RTC_AlarmConfig(SD_CardLogging_StepHours, SD_CardLogging_StepMinutes, SD_CardLogging_StepSeconds);
    }
    
     SD_CardLoggingMemsData();
  }
}

/**
 * @brief  Check if there are a valid Data Log Status Values in Memory and read them
 * @param  None
 * @retval unsigned char Success/Not Success
 */
static unsigned char ReCallDataLogStatusFromMemory(void)
{
  /* ReLoad the Node Name Values from RAM */
  unsigned char Success=0;

  /* Recall the Data Log Status Credential saved */
  MDM_ReCallGMD(GMD_DATA_LOG_STATUS,(void *)&DataLogStatus);
  
  if(DataLogStatus[0] != ((uint32_t)0x12345678))
  {
    DataLogStatus[0]= (uint32_t)0x12345678;
    DataLogStatus[1]= (uint32_t)0x00000000;
    DataLogStatus[2]= (uint32_t)0x00000000;
    DataLogStatus[3]= (uint32_t)0x00000000;
    DataLogStatus[4]= (uint32_t)0x00000000;

    MDM_SaveGMD(GMD_DATA_LOG_STATUS,(void *)&DataLogStatus);
    NecessityToSaveMetaDataManager=1;
  }

  return Success;
}

/**
 * @brief  Check if there are a valid Mems Data File Name in Memory and read them
 * @param  None
 * @retval unsigned char Success/Not Success
 */
static unsigned char ReCallMemsDataFileNameFromMemory(void)
{
  /* ReLoad the Node Name Values from RAM */
  unsigned char Success=0;

  /* Recall the RTC Last Alarm Credential saved */
  MDM_ReCallGMD(GMD_MEMS_DATA_FILENAME,(void *)&MemsDataFileName);
  
  if(MemsDataFileName[0] != 'C')
  {
    MemsDataFileName[0]= 'C';
    
    for(int i=1; i<41; i++)
      MemsDataFileName[i]= '0';

    MDM_SaveGMD(GMD_MEMS_DATA_FILENAME,(void *)&MemsDataFileName);
    NecessityToSaveMetaDataManager=1;
  }

  return Success;
}
#endif /* ALLMEMS2_ENABLE_SD_CARD_LOGGING */

#ifdef ENABLE_SHUT_DOWN_MODE 
void ShutdownTimeOutStart(void)
{
  if (!timShutDownId) {
    timShutDownId     = osTimerCreate (osTimer(TimerShutDownTimeOutHandle),osTimerOnce, NULL);
  }
  if (timShutDownId){
    if  (osTimerStart (timShutDownId, SHUT_DOWN_TIME_OUT) != osOK){
        ALLMEMS2_PRINTF("failed starting shutdown timer\n\r");
    }
  }
}
void ShutdownTimeOutReset(void)
{
  if (timShutDownId){
    if  (osTimerStart (timShutDownId, SHUT_DOWN_TIME_OUT) != osOK){
        ALLMEMS2_PRINTF("failed starting shutdown timer\n\r");
    }
  }
}
void ShutdownTimeOutStop(void)
{
  if (timShutDownId) {
    if  (osTimerStop (timShutDownId) != osOK){
      ALLMEMS2_PRINTF("could not stop shutdown timer\n\r");
    }
    if (osTimerDelete (timShutDownId) != osOK)  {
      ALLMEMS2_PRINTF("could not delete shutdown timer\n\r");
    }
    timShutDownId = NULL;
  }
}
static void ShutDownTimeOutCb  (void const *arg) 
{
  MCU_PowerSave();
}
#endif /* ENABLE_SHUT_DOWN_MODE  */

void LedBlinkStart(void)
{
  ledTimer = LED_TIME_ON;
  LedOnTargetPlatform();
  if (!timLedId) {
    timLedId     = osTimerCreate (osTimer(TimerLedHandle),osTimerOnce, NULL);
  }
  if (timLedId){
    if  (osTimerStart (timLedId, ledTimer) != osOK){
        ALLMEMS2_PRINTF("failed starting timer\n\r");
    }
  }
}

void LedBlinkStop(void)
{
  LedOffTargetPlatform();
  if (timLedId) {
    if  (osTimerStop (timLedId) != osOK){
      ALLMEMS2_PRINTF("could not stop led timer\n\r");
    }
    if (osTimerDelete (timLedId) != osOK)  {
      ALLMEMS2_PRINTF("could not delete led timer\n\r");
    }
  timLedId = NULL;
  ledTimer = (uint32_t)NULL;
  }
}

static void LedBlinkCb  (void const *arg) 
{
  if (ledTimer == LED_TIME_ON){
    ledTimer = LED_TIME_OFF;
    LedOffTargetPlatform();
  }
  else{
    ledTimer = LED_TIME_ON;
    LedOnTargetPlatform();
  }
  if (timLedId){
    if  (osTimerStart (timLedId, ledTimer) != osOK){
        ALLMEMS2_PRINTF("failed starting timer\n\r");
    }
  }
}

void vApplicationStackOverflowHook (void)
{
  while (1)
  {

  }
}


void vApplicationMallocFailedHook (void)
{
  while (1)
  {

  }
}
/******************* (C) COPYRIGHT 2020 STMicroelectronics *****END OF FILE****/
